#include <algorithm>
#include <bitset>
#include <cstdint>
#include <iostream>
#include <set>



// функция для инвертирования 
// возвращает bool - "успешно ли прошла операция?"
bool invert(uint8_t *start, uint8_t *end, const std::set<size_t> &idx) {

    // если индексов нет - ничего делать не нужно, возвращаем true
    if (idx.empty()) return true;
    // получаем наибольшее значение из списка индексов
    auto max_bit = *idx.rbegin();

    // если количество битов в инвертируемой последовательности
    // меньше, чем наибольший индекс - возвращаем false
    if (((end - start) * 8) <= max_bit) {
        std::cerr << "Index " << max_bit << " greater than bit sequence\n";
        return false;
    }


    // проходим по всем индексам битов, которые нужно инвертировать
    for (auto id : idx) {
        // создаем маску для одного бита, смещенного на искомую позицию (без учета номера байта)
        uint8_t mask = 1 << id % 8;
        // ищем байт, в котором нужно применить полученную маску 
        // (считаем с конца, поскольку младший бит считается с конца, 
        // а последовательность байтов мы расцениваем как единую сущность)
        auto position = (end - 1) - (id / 8);
        // накладываем маску
        *position ^= mask; 
    }

    // все хорошо - возвращаем true
    return true;
}


// вспомогательная функция для отображения массива в виде битов
void show_sequence(uint8_t *start, uint8_t *end) {
    while (start != end) {
        std::cout << std::bitset<8>(*start);
        ++start;
    }
    std::cout << std::endl;
}



int main() {

    // задаем размер последовательности
    constexpr size_t seq_size = 10;
    // создаем последовательность байтов (имитируют участок памяти)
    uint8_t seq[seq_size] = {15, 30, 45, 60, 75, 90, 105, 120, 135, 150};
    // задаем индексы битов, которые нужно инвертировать
    // используется set, потому, что значения в нем уже отсортированы и уникальны
    std::set<size_t> idx{0, 1, 2, 3, 4, 5, 6, 7, 16, 32, 33, 34, 35, 36, 37, 38, 39, 40, 77, 78, 79};

    // смотрим исходную последовательность байтов
    show_sequence(seq, seq+seq_size);
    // инвертируем
    bool success = invert(seq, seq+seq_size, idx);
    // если что то пошло не так - прерываем программу с ошибкой
    if (!success) {
        std::cerr << "Not success" << std::endl;
        return 1;
    }
    // смотрим получившуюся последовательность
    show_sequence(seq, seq+seq_size);

    return 0;

}



// Задание звучит так: 
// Напишите функцию, которая инвертирует только выбранные биты в участке памяти, 
// заданном указателем и длиной в байтах. 
// Способ выбора битов для инвертирования на ваше усмотрение.

